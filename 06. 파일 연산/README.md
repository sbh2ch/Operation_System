# 파일 연산 (File Operations)
> 파일 연산을 위해서는 운영체제가 제공하는 파일서비스가 무엇인지 알아야한다

* 운영체제의 시스템 호출 (system call)로서 제공
* 파일 생성 (create) 
  * 파일 시스템 내에 공간 확보, 디렉터리에 파일 정보 추가
* 파일 삭제 (delete)
  * 파일에 할당된 저장 공간을 반납 (release)
    * 일반적으로 **저장 공간 자체를 삭제하는 연산은 하지 않음** : 파일 속성정보를 담고있는 디렉토리에서 파일 정보만 지운다.
  * 디렉터리에서 파일 항목을 삭제
* 파일 쓰기 (write)
  * **파일 이름과 기록될 데이터를 명시**하여 시스템 호출
  * 디렉토리를 검색하여 파일 위치 찾음 : 디렉토리 내 파일 속성정보를 찾아내고, 파일 위치를 알아내서 저장장치에 있는 파일을 찾아간다.
  * 쓰기 포인터를 유지하면서 데이터 기록 
* 파일 읽기 (read)
  * 디렉토리 내 파일 속성정보를 가지고 하드디스크 내 파일 위치를 찾아낸다. 이후 파일 포인터 이후부터 읽기 시작한다.
  * **파일 이름과 저장될 메모리 위치(주소)를 명시**하여 시스템 호출 
  * 디렉토리를 검색하여 파일 위치 찾음 
  * 읽기 포인터를 유지하면서 데이터 읽음
> Linux에선 파일 쓰기 읽기 포인터를 따로 구분하지 않고, 파일 포인터로 합쳐서 사용하고 있다.

## 추가적인 파일 연산
위 4개의 파일 연산 외에도 추가적인 파일 연산을 제공한다.

* 파일 내의 연산 위치 설정 (reposition)
  * 위에서 파일에 데이터를 읽거나 쓸때 파일포인터를 이용한다고 했었다. 필요에 따라선 이전에 끝난 위치가 아니라 내가 원하는 위치에서 파일 read,write를 하고싶을때가 있는데, 그때 사용한다.
  * 주어진 값으로 파일 위치 포인터 (file-position pointer)를 변경
  * 파일 탐색(seek)라는 이름으로 알려져 있음
* 파일 절단 (truncate)
  * 파일자체는 유지한채 데이터만 새로 쓰게되는데 이때 이 기능을 이용하면, 파일의 속성은 유지한채로 내용만 바뀐다.
  * 파일의 속성을 유지한 채로 파일의 내용 삭제
  * 파일 길이는 0으로 재설정
* 기타 연산
  * append, rename, get,set attribute

## 파일 연산 - 파일 열기 (open)
> 일반적으로 앞에서 봤던 파일 생성삭제 읽기 쓰기 등 모든 연산은 파일이 어디있는지, 어떤 특성이 있는지 디렉토리에서 파일 속성정보를 알아내고 원하는 작업을 한다. <br/>
> 그래서 매번 파일 연산 할때마다 디렉토리 살펴보는 작업은 파일 시스템 작업을 느리게하는 비효율적인 동작이다.<br/>
> 그래서 운영체제의 파일시스템은 파일 서비스를 설계할때, 파일의 open을 만들어 놨다. <br/>
> 한번 open으로 파일을 열어두면 그 파일에 대한 속성정보를 디렉토리에서 메모리로 복사해두게된다.<br/> 
> 그래서 그 이후의 파일연산은 디렉토리를 뒤지지않고 메모리에 있는 정보에 빨리 접근한 다음 실제 저장장치에는 내가 원하는 read, write 등 만 할수 있게 도와준다.<br/>
> 옵션이 아니고 파일관련된 연산에서 **반드시 해야하는 작업**이다.

* open() system call
  * 대부분의 파일 연산은 디렉토리에서 파일 정보 검색이 우선되어야 한다.
  * 디렉토리의 파일 정보를 시스템 내(메모리)에 복사하여 유지
    * 열린 파일들의 테이블(open-file table)
    * **파일 테이블의 인덱스로 파일 정보를 참조** : 오픈 이후는 리드 라이트 할때 파일 이름을 주는것이 아니라 오픈된 파일테이블의 인덱스 번호를 줌으로써 좀더 편리하게 파일에 대한 접근을 수행할수있다. 
    * 이때 파일 테이블에 대한 인덱스를 리눅스에선 `file descriptor`라고 얘기한다. 윈도우즈에선 `file handle`이라고 한다.
      * 유닉스/리눅스에서 파일 디스크립터(file descriptor)
  * 파일 접근 모드 명시(권한과 사용 용도)
  
* 파일에 대한 여러 프로세스의 동시 접근이 허용되는 경우
  * 2단계 파일 테이블 유지 : 파일 테이블을 통해서 여러가지 파일작업을 실행한다고 했을 때, 여러개의 프로그램이 한 파일을 읽을 수 있다. 
  * 이때 하나의 파일테이블을 공유하게되면 문제가 생기게 된다. 
  * 그래서 file open을 통해서 유지하되 커널 전체적으로 각 파일에 하나씩 유지하는 테이블을 가지고있지만 각각의 프로그램마다의 파일 테이블을 가지고 있다. 
  * 파일의 전체적인 정적인 정보는 커널에서 테이블을 가지고있고, 동적으로 변할수 있는 부분은 프로그램마다 파일테이블을 가지고 있는다. 
  * 프로세스 개별 파일 테이블
    * 현재 파일 포인터, 파일 접근 권한 및 accounting 정보 등
  * 시스템 전체(system-wide) 파일 테이블
    * 저장장치에서의 파일 위치, 접근 날짜 및 파일 크기 등
    
## 열린 파일을 위한 정보
> 파일 테이블 안에 담기는 정보 : 디렉토리 안에 있는 파일의 속성정보의 대부분이다. 그래서 디렉토리 참조 안하더라도 파일에 대한 엑세스가 가능하게 된다.
* **파일 포인터**(file pointer)
  * 마지막 파일 읽기/쓰기가 끝난 위치
  * 각 프로세스 마다 별도로 유지 (디스크에 저장되는 속성이 아님)
* 파일 열림 개수 (file-open count)
  * 동일한 파일을 여러 프로세스가 반복해서 열 수 있음
  * 마지막 열린 파일이 닫혔을 때(close), 파일 테이블 항목을 삭제 -> open count가 0이 될때.
* 디스크에서 파일의 위치 (location)
  * 파일 연산 마다 파일 위치를 검색하지 않도록 열린 파일 테이블에 저장
* 접근 권한 (access rights)
  * 각 프로세스가 해당 파일에 대해 가지는 접근 모드
    * 운영체제에 의해 허용 혹은 거부
