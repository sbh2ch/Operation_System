# 프로세스의 개념과 상태
운영체제가 수행해야 할 역할 중 프로그램의 실행이 **가장 중요한 역할**이다. <br/>
현대의 운영체제는 한 번에 하나의 프로그램이 아닌 동시에 여러 가지 프로그램이 수행되는 것처럼 보이는 멀티태스킹이 필수다. 그리고 운영체제는 컴파일된 결과물인 프로그램과 실행되는 프로그램을 별도로 프로세스란 이름으로 구분 짓고 있다.<br/>
<br/>
프로그램을 관리한다는 것은 파일시스템안의 파일로써 프로그램을 잘 저장하면 되는 거지만, 프로세스를 관리하는 것은 보다 더 복잡한 기능이 필요하게 된다.<br/>
특히 여러 개의 프로세스가 동시에 실행되게 하기 위해선 cpu와 같은 자원을 공평하고 효율적으로 할당할 방법이 필요하고, 또 여러 개의 프로세스 혹은 커널 사이에서 **충돌이 발생하지 않게 하는 관리기법**이 필요하다.<br/>
<br/>
이번에는 프로세스의 실행과 관리를 위한 운영체제의 동작원리, 설계 기법을 학습 할 것이다.<br/>
먼저 프로세스의 개념에 대해 살펴보겠다.<br/>

## 프로세스
> 컴파일 돼서 저장장치에 저장된 파일형태는 프로그램, 이것이 메모리에 적재되서 cpu를 통해 실행되는 상태를 프로세스라고 한다. 실행 중인 프로세스는 단순히 컴파일된 코드로만 이루어져 있지 않다. 아래와 같은 다양한 데이터들이 필요하다.
* 프로세스는 실행 중인 프로그램이다.
* 프로세스의 구성 요소
  * 프로그램 코드 : `text-section` 
  * 프로그램 카운터 : `progrom counter, PC`  // cpu 입장에서 필요한 정보
    * 다음에 실행할 명령(instruction)의 주소
  * CPU 레지스터 내용  // cpu 입장에서 필요한 정보
  * 프로세스 스택(stack) // 나머지 아래 3개는 프로세스가 실행될때 필요한 데이터
    * 함수의 구조로써 프로그램이 실행될때 각각의 함수 안에서 필요한 데이
    * 매개변수 `parameter`, 복귀 주소`return`, 지역 변수 `local variable`
  * 데이터 섹션 `data section`
    * 전역 변수 `global variable`
  * 힙 `heap`
    * 실행 중에 동적으로 할당되는 메모리
    * C에서의 `malloc` , `free`
    
## 메모리 상의 프로세스
![processInMemory](../images/lec8/processInMemory.png)

위는 프로세스의 구성 요소 중 프로그램 코드, 데이터 섹션(stack, heap, data)가 어떻게 메모리에 저장되는지 나타내는 그림이다. <br/>
프로그램은 전체 메모리 주소를 자신만 쓸 수 있는 가상메모리를 할당받아서 맨 아래쪽에 컴파일된 프로그램 코드(text)가 들어가고 그 위에 데이터, 힙, 스택이 들어간다.<br/>
<br/>
스택이란 것이 함수 호출을 위해 사용한다고 했는데,  컴퓨터 시스템에서는 자기가 사용하는 메모리 영역의 가장 위쪽부터 아래쪽으로 내려오는 식으로 스택을 유지한다. 힙은 할당된 시점부터 위로 올라가게 되어있다.<br/>
그림에서 보면 알듯이 스택과 힙은 어떤 프로세스가 컴파일되고 실행된다고 할때 크기가 결정되지 않고 프로그램 실행조건에 따라 변할 수 있기 때문에 화살표모양으로 그려졌다.<br/>

## 리눅스 프로세스의 메모리 구성
![linuxMemory](../images/lec8/linuxMemory.png)

이 그림은 앞에서 봤던 간단한 그림을 실제 리눅스에서의 메모리상의 주소 값까지 상세하게 그린 것이다. <br/>
`text segment`가 위의 코드고 초기화된 데이터(Data segment), 초기화 되지 않은 데이터(BSS segment)가 데이터에 해당한다. <br/>
전역변수를 선언하더래도 처음에 값을 설정한 변수가 있고, 실제로 프로그램 코드가 실행되면서 값이 할당될 수가 있다.<br/>
그 위에 힙영역, 스택이 있다.<br/>
> 이 그림에서 스택위에 `kernel space`가 들어간다. 
운영체제는 `가상 메모리`라고, 실제로 pc의 램을 쪼개서 쓰는 게 아니라 메모리 관리를 통해서 각각의 프로세스에게 4gb라는 메모리를 다 할당한 것처럼 느끼게 만든다.
여기서 `kernel space`는 프로그램이 실행될 때 `system-call`로 커널서비스를 이용하게 되는데, 그때도 어딘가 메모리영역으로 프로그램 점프가 일어나야 한다. 그것을 같은 프로세스 내 메모리 공간에 포함하기 위해서 `kernel space` 공간을 마련해둔 것이다.

중간에 memory mapping region이 있는데. 여기는 파일을 메모리에 연결시켜 사용할 때 들어가는부분, 라이브러리 함수들이 존재하는 위치 등이 스택과 힙의 중간 부분이다.<br/>

![linuxMemory2](../images/lec8/linuxMemory2.png)

printf같은 라이브러리 함수는 중간 memory mapping region에 들어간다.<br/>
> 이때 유의할 건 printf가 여기 들어가 있는 거처럼 메모리맵만 만들어지는 것이지 실제로 들어가 있는 건 아니다. 아래쪽도 사실 0부터 시작하는 건 아니고 32비트 경우 0x08048000, 64비트 경우 0x00400000 에서 시작한다.<br/>
가장 밑부분도 커널이 사용하기 위한 특수한 영역으로 남겨둔다. 만약 그 메모리를 강제로 접근하려면 에러가 발생한다.

요약은.. 프로세스라는 것은 실행되는 프로그램인데, **컴파일된 코드 말고도 자기 자신을 실행하기 위한 변수들을 데이터 힙 스택으로 나눠서 쓰고 있다는 것!** 

## 프로세스 상태 (process state)
CPU는 절대로 여러개의 프로세스를 동시에 실행할 수 없다. 동시에 실행하려면 여러 개의 CPU가 필요하다.<br/>
<br/>
그런데 운영체제는 멀티 태스킹이라는 절묘한 기법을 통해 사람이 느끼기에 여러개의 프로세스가 하나의 cpu에서 동시에 실행되는 것처럼 느끼게한다.<br/>
하나의 프로세스는 실행이 시작되면 종료될 때까지 쭉 cpu에서 실행되는것이 아니라 실행되다가 멈췄다 다시 실행했다가 하는 식으로 진행된다.<br/>
그래서 일반적인 운영체제에서 프로세스관리를 말할 때 **프로세스는 상태를 가지고 있다**는게 중요한 개념이다.<br/>
<br/>

* 프로세스 상태 (process state)
  * 프로세스 실행 중에 상태 변경(transition)
  * 많은 프로세스가 하나의 cpu를 공유하기 위해 필요한 개념
* 프로세스 상태의 전형적인 종류
  * `New` : 프로세스가 생성되는 중이다.
  * `Running` : CPU에서 명령(instruction)이 실행되는 중이다.
    * 실제로 cpu에서 프로그램 코드가 실행되는 상태
  * `Waiting` : 프로세스가 어떤 사건(입출력 완료, 신호(signal), software interrupt)이 발생하기를 기다리는 중이다.
    * 만약 파일 읽기 위해 fread를 호출하면 이때 프로세스는 cpu를 실행하면서 read를 기다리는 게 아니라 waiting상태에서 입력이 들어오길 기다리게 된다.
    * cpu가 놀고 있다고 하더라도 (입력, 출력, 신호)가 도달하지 않는다면 cpu를 차지하지 못하는 상황이다.
  * `Ready` : 프로세스가 CPU에 할당되어 실행되기를 기다리는 중이다.
    * `Running`할 준비가 된 상태
    * cpu가 실행하지 않는 프로세스는 운영체제 시스템 안에 여러 개가 존재하게 된다. 그래서 이 waiting과 ready를 둠으로써 실행하지 않는 프로세스를 효율적이고 공평하게 관리하는 방법을 마련한다.
  * `Terminated` : 프로세스가 실행을 종료하였다.

## 프로세스 상태도 (state diagram)

![state](../images/lec8/state.png)

1. 프로그램 처음 실행하면 new 상태에 들어간다. 아직은 cpu를 차지하지 못한다. 
2. cpu를 차지할 상황이 되면 운영체제로부터 admitted를 받아서 `running`하게 된다.
3. 하지만 실행을 준비할 것들이 많아서 바로 `running`으로 가지 못하고 `ready`상태를 거쳐야 한다.
  * 그러면 `ready`에서 언제 `running`으로 갈까
  * 바로 `scheduler`가 dispatch하면 된다.
    > 여기서 `schduler`란 것은 운영체제의 요소 중 아주 중요한 부분이고 여러 개의 프로그램이 동시에 실행되는 거처럼 규칙을 부여하는 것이 운영체제의 `scheduler`라고 한다. 상당히 중요하므로 `micro kernel`에도 포함되는 부분이다.<br/> 대부분의 프로세스들은 대부분 `ready`상태에 있는 것이고 단 하나만 `running`으로 가는것이다. 그것은 스케줄러의 정책에 따라 선택되는 것이다.
4. 한 프로세스 입장에선 ready에 있다가 running으로 가게되면 실제 cpu를 사용해서 자기가 하고자 하는걸 실행한다. 
5. 그런데 이게 계속해서 끝까지 실행되는 게 아니라 어떠한 조건을 만족하면 실행을 멈춘다. 
  * 그 조건은 총 3가지가 있다.
    1. 종료된다면 `exit`가 된다
    2. 실행하다가 scanf, read, printf 등 외부 장치에 대해 입출력을 요구했을 때 (I/O or event wait) 외부 장치가 동작하는 시간은 cpu가 동작하는 시간보다 수천 배에서 수십만 배 이상 느리다. 그동안 cpu가 아무거도 안 하고 대기하는 게 아니라 프로세스가 `waiting`으로 빠지게 되고 이 cpu는 다른 프로세스에게 할당한다. <br/> 이 `waiting`이 언제 끝날지는 프로그램은 알 수 없다. 바로 그것을 알려주는 것이 I/O or event completion 이다. 이것은 인터럽트에 해당한다. I/O completion interrupt 가 발생하면 `waiting`인 프로세스가 `ready` 로 넘어가게 된다.
    3. 계속 `running` 을 해야되고 I/O를 하지 않음에도 실행상태를 벗어나야 하는 상황이 발생한다. **이게 바로 운영체제 스케줄러가 여러 프로세스가 동시에 실행되는 거처럼 해주는 중요한 수단**이 된다. <br/> 운영체제는 한 프로세스가 긴 시간을 혼자사 용하도록 내버려 두는게 아니다. 일정한 시간이 지나면 (1ms, 수 ms 정도) 마다 인터럽트가 발생한다. `timer interrupt`가 실행되면 운영체제가 현재 실행 중인 프로세스를 중지를 시키고 `ready`상태로 빼놓게 된다. 그 빠진 프로세스 대신 기다리고 있는 다른 프로세스를 `running`으로 넣는다. 

## 프로세스 제어 블록 (process control block)
운영체제는 한 프로세스가 실행되면 여러 상태 사이를 계속 변경해가면서 프로세스 실행을 관리하게 된다. <br/>
실행 중인 프로세스가 `ready` 로 갔다 `running`할때 중단된 시점으로 가려면 그 프로세스가 어디까지 실행했는지, 또 그 프로세스가 실행될 때 레지스터에는 어떤 값들이 들어있었는지, 몇 초 동안 사용했는지 등의 정보가 계속 유지되고 있다가 다음번 사용할 때 복원돼야 한다.<br/>
그러기 위해서 프로세스의 제어를 위한 정보를 따로 모아서 별도의 커널 공간에 저장하고 관리한다.<br/>
<br/>
이건 마치 파일 입출력을 처리하기 위해 파일 속성정보를 파일 테이블이라는 곳에 별도로 유지하고 파일 디스크립터로 테이블만 엑세스하면 하드디스크에 있는 디렉토리나 파일 이름을 다시 검색할 필요 없이 엑세스 할 수 있었던 것 처럼.
바로 그와 비슷하게 프로세스를 관리하기 위한 여러가지 속성정보를 커널의 별도 공간에 보관하는데 그게 바로 프로세스 제어 블락`Process Control Block, PCB`이라고 한다. <br/> 
<br/>
하나의 프로세스마다 아래 그림과 같은 자료구조가 하나 만들어지는 것이고, 운영체제가 관리한다.<br/>
프로세스들이 계속 실행되지 않고 상태가 변하더라도 다시 실행할 때 마치 그 프로세스 입장에선 중단된 게 아니고 계속 실행되고있는 것처럼 연속적으로 실행할 수 있게 된다.<br/>
<br/>
![block](../images/lec8/controlBlock.png)

* 프로세스 제어 블록 (Process Control Block, PCB)
  * 프로세스의 실행을 제어하는 데 사용하기 위한 자료구조
  * 운영체제의 메모리 공간에 저장
* 프로세스 제어를 위한 정보
  * 프로세스 상태 (process state)
  * 프로그램 카운터 (PC)
  * CPU 레지스터
  * CPU 스케줄링 정보
  * 메모리 관리 정보
  * 회계 (accounting) 정보
  * 입출력 상태 (I/O status) 정보
  
### Linux의 PCB

리눅스의 커널 소스를 보면 /include/linux/sched.h 라는 헤더파일에 `task_struct`라는 구조체에 정의되어있다.
바로 이것이 `PCB 정보`이다.<br/>
실제로 커널이 동작하면 각각의 `PCB`는 `linked list`형태로 구성된다.

## 문맥 교환 (context switch)
> 앞에서 본 프로그램이 프로세스가 실행될때 계속 상태가 변경된다고 했었다. 이때 `running`이 `ready`로 가고 `ready`가 `running`으로 바뀌는게 바로 `context switch`다. 즉 프로세스 교환이다. 

* 프로세스의 문맥 (context)
  * 프로세스 제어를 위한 다양한 정보 (PCB에 저장되는 정보)
    * 프로세스 상태가 변한다는것은 단지 실행 프로세스의 상태가 `running` <-> `ready` 로 바뀌는 것 만 아니라, 그 프로세스 실행되는데 필요한 **여러가지 부가정보**들이 같이 저장되었다가 복구되는게 필요하다.
    * 프로세스의 `context`라 하면 그 프로세스의 단순한 코드 뿐만 아니라 그 **프로세스가 상태 제어를 통해 동작할 때 프로세스 제어를 하기 위해 필요한 다양한 정보**를 `context`라 한다.
    ![linked](../images/lec8/linked.png)
    * 프로세스의 상태가 변한다는것은 위 사진에서 첫번째 프로세스의 문맥이 PCB에 저장되었다가 2번 프로세스 문맥이 PCB로 부터 각종 메모리나 CPU, 레지스터, Program Counter로 복구 되는 과정, 즉 문맥이 교환되는 과정이 바로 프로세스 교환이 된다. 
    * 프로세스 상태, 프로그램 카운터, 레지스터 값 등
* 문맥 교환 (context switch)
  * 실행되는 프로세스가 교체되는것
  * 엄격한 의미는 문맥이라는것은 실질적으로 PCB에 저장되는 정보이다.
  * 이 프로세스가 돌아가는데 필요한 문맥정보를 커널메모리에 있는 PCB의 자료구조에 저장하고, PCB에 저장되어있는 다른 프로세스의 문맥을 CPU나 필요한 메모리공간으로 복구하는것.
  * PCB를 매개로 해서 문맥을 저장하고 복구하는것이 바로 문맥 교환이다.
  * 후에 스케줄을 얘기할때도 비슷한 개념을 다시 살펴볼 예정이다.
  * 스케줄러가 CPU를 다른 프로세스에게 할당하려고 할 때 현재 프로세스의 문맥을 PCB에 저장하고 새로운 프로세스의 PCB로 교체하는 것
* 문맥 교환 비용 (overhead)
  * 프로세스가 동시에 동작하는것처럼 운영체제가 서비스 하기위해선 프로세스 상태를 계속 바꿔줘야되는데 사실 이게 간단치 않은 작업이다.
  * 어떤 프로세스를 실행하느냐 결정하는것도 어렵고, 결정된다고 하더라도 문맥교환 과정을 위해서 문맥 정보를 PCB에 저장하고 복구하는 시간이 필요하다
  * 문맥교환이 빨라지면 동시에 많은 프로그램을 실행할 수 있는 장점이 있지만 프로그램의 순수 실행시간 외에 문맥 교환을 위한 시간이 더 필요하다.
  * CPU입장에선 많은 메모리 IO가 발생한다.
  * 보통 이런걸 실제로 내가 사용하는 시간이 아니기 때문에 `overhead` 라고 부른다.
  * 운영체제는 스케줄링을 잘 해야하는데, 이때 문맥교환의 비용을 적게하는것도 설계 최적화 과정이 된다.
  * PCB에 저장과 복구 시간 동안 프로세스의 유효한 작업은 중지
  * 운영체제 및 프로세스의 성능에 중요한 영향을 준다.
  
## CPU의 프로세스 교체 (switch)
![switch](../images/lec8/switch.png)

이 그림은 어떤 두 개의 프로세스가 스위칭하는 과정 중 문맥 교환이 일어나는걸 도식화해서 보여준다. 여기서 문맥 교환이 일어나는 원인은 인터럽트나 시스템콜이다.

> 문맥교환이 언제 일어날까? running 중인 프로세스가 IO작업이나 시스템콜로 waiting으로 가거나 인터럽트로 ready로 가거나 실행종료에 의해 exit으로 갈 때 발생한다.

* 파란색 화살표가 실제 CPU에서 실행되는것, 검정색은 프로세스는 살아는 있지만 CPU에선 실행되지 않는 `idle` 상태이다. 
* 보면 파란 화살표가 시간을 정확히 나눠쓰는게 아니라 검정색(idle)이 겹치는 공간이 발생한다, 이것이 바로 `overhead`다.

1. 현재 실행되고 있는 프로세스에 interrupt 발생 혹은 system call 을 호출하면, 문맥교환 과정이 일어난다. 어떤 작업을 선택할지는 os의 스케줄러가 dispatch하게된다.
2. 맨 먼저 하는일은 실행중인 프로세스의 문맥을 이 프로세스의 PCB에 저장하고, 이전에 저장되어있던 P1의 PCB 안에 있는 P1 문맥을 로딩해서 CPU 혹은 다른 메모리 영역에 reload 한다.
3. 2가 완료되면 P1 프로세스가 실행된다. 만약 P1에서도 똑같이 인터럽트 혹은 시스템콜이 발생하면 같은 일이 발생되며 P0로 스위칭 된다.


